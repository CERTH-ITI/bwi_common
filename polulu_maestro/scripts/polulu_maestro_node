#!/usr/bin/env python

# This code is based on code available at the following location: 
# https://www.assembla.com/code/XD_DSbot/subversion/nodes/trunk/Info/Simu/PololuMaestro.py?rev=405
# The original code is unlicensed, and has been re-packaged as BSD in this 
# code-release. Please contact the package distributors in case of licensing
# discrepancies
#
# Copyright (C) 2014, The XD_DSbot Dev Team, Jack O'Quin, Piyush Khandelwal
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of the author nor of other contributors may be
#    used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

"""
This is a ROS device driver node that interacts with a Polulu Maestro Servo
Controller. It has been tested on the Polulu Micro MaestroDevice, but should
also work with the Polulu Mini MaestroDevice 12, 18 and 24.

.. note::

   TODO: add diagnositics

"""

import math
import rospy
import serial
import time

from std_msgs.msg import Float32

MIN_TICK = 2080
MAX_TICK = 9920

def radians_to_ticks(rads):
    return (MIN_TICK + MAX_TICK) / 2 + \
           int((rads / math.pi) * (MAX_TICK - MIN_TICK)) 

def ticks_to_radians(ticks):
    return (ticks - (MIN_TICK + MAX_TICK) / 2) * \
            math.pi / (MAX_TICK - MIN_TICK)

class MaestroDevice:
    """ Class for managing the Polulu Maestro Servo Controller """

    def __init__(self, port='/dev/ttyACM0', baud=9600):
        self.port = port
        """ Path name for Arduino serial port. """
        self.baud = baud
        """ Baud rate for Arduino serial port. """
        self.dev = None
        """ Arduino serial device connection. """

    def close(self):
        if self.dev:
            self.dev.close()
        self.dev = None

    def ok(self):
        """ :returns: ``True`` if Arduino contacted. """
        return self.dev is not None

    def open(self):
        """ Open the Maestro serial device interface.

        :returns: ``True`` if open succeeds.
        """
        try:
            self.dev = serial.Serial(self.port, self.baud)
            # give a little time to the MaestroDevice to breeze 
            time.sleep(0.25)
        except IOError as e:
            # HACK: serial does not return errno.ENOTTY as it should,
            #       so check the exact string.
            enotty = ("Could not configure port: "
                      + "(25, 'Inappropriate ioctl for device')")
            if str(e) != enotty:        # is it a serial port?
                rospy.logerr('Serial port open failed at '
                             + str(self.baud) + ' baud: ' + str(e))
                return False
            else:
                rospy.logerr('Serial port is not configured as tty ' +
                             '(errno.ENOTTY): ' + str(e))
                return False
        else:
            rospy.loginfo('Serial port ' + self.port + ' opened at '
                          + str(self.baud) + ' baud.')
            self.dev.flushInput()       # discard any old data
            return True
  
    def __send_header(self, cmd, device):
        """ Sends the header of the command, depending ont the protocol """
        if  (device & 0x80) == 0 :              #Pololu protocol
            self.dev.write(chr(0xAA))           #start byte
            self.dev.write(chr(device & 0x7f))  #device
            cmd &= 0x7f                         #in this mode, the MSB of the 
        self.dev.write(chr(cmd))                #command is cleared

    def __send_command(self, cmd, device):
        """ Sends a command without data """
        self.__send_header(cmd, device)

    def __send_command_b(self, cmd, byte_arg, device):
        """ Sends a command with 1 byte of data """
        self.__send_header(cmd, device)
        self.dev.write(chr(byte_arg & 0x7f))

    def __send_command_bi(self, cmd, byte_arg, int_arg, device):
        """ sends a command with 3 byte of data """
        self.__send_header(cmd, device) 
        self.dev.write(chr(byte_arg & 0x7f))
        self.dev.write(chr(int_arg & 0x7f))        #data lower 7 bits
        self.dev.write(chr((int_arg >> 7) & 0x7f)) #data bits 7-13

    def __send_command_ii(self, cmd, int_arg1, int_arg2, device):
        """ sends a command with 4 bytes of data """
        self.__send_header(cmd, device) 
        self.dev.write(chr(int_arg1 & 0x7f))        #data lower 7 bits
        self.dev.write(chr((int_arg1 >> 7) & 0x7f)) #data bits 7-13
        self.dev.write(chr(int_arg2 & 0x7f))        #data lower 7 bits
        self.dev.write(chr((int_arg2 >> 7) & 0x7f)) #data bits 7-13

    def __send_command_var_i(self, cmd, byte_arg, int_values, device):
        """ Sends a command with variable bytes of data """
        self.__send_header(cmd, device)
        self.dev.write(chr(len(int_values)))     #number of int values
        self.dev.write(chr(byte_arg & 0x7f))     
        for i in int_values:
            self.dev.write(chr(i & 0x7f))        #data lower 7 bits
            self.dev.write(chr((i >> 7) & 0x7f)) #data bits 7-13

    def __receive_int(self):
        """ Receives 2 bytes of data """
        low  = self.dev.read()
        high = self.dev.read()
        return int(ord(low) | (ord(high) << 8))

    def __receive_byte(self):
        """ Receives 1 byte of data """
        return ord(self.dev.read())

    def set_target(self, servo, angle, device=0x80):
        """ Set the target for a servo
        :param servo: is the servo number (typically 0-23)
        :param angle: is the target, from 256 to 13120, in quarter-microseconds
                      (center=6000, off=0)
        :param device: is the id of the MaestroDevice device (0-127, default on
                       boards is 12, all device if not set)
        """
        self.__send_command_bi(0x84, servo, angle, device)

    def set_target_minissc(self,servo, angle):
        """ Set the target using the Mini-SSC protocol
        :param servo: is the sum of the servo number (typically 0-23) and the
                      servo offset of the device
        :param angle: is the target, from 0 to 254, mapped between
                      neutral-range and neutral+range. 127 is neutral.
        """
        self.dev.write("\xFF"+chr(servo)+chr(angle))

    def set_multiple_targets(self, first_servo, angles, device=0x80):
        """ Set simultaneously targets for a contiguous block of servos (Mini
        MaestroDevice 12, 18 and 24 only)
        :param first_servo: is the lower servo number in the block 
                            (typically 0-23)
        :param angles: is the list of targets, each from 256 to 13120, in
                       quarter-microseconds (center=6000, off=0)
        :param device: is the id of the MaestroDevice device (0-127, default on
                       boards is 12, all device if not set)
        """
        self.__send_command_var_i(0x9F, first_servo, angles, device)

    def set_speed(self, servo, speed, device=0x80):
        """ Set the speed for a servo
        :param servo: is the servo number (typically 0-23)
        :param speed: is the servo speed (0=full, 1=slower), in 
                      (0.25 us)/(10 ms) when T=20ms. 
                      see http://www.pololu.com/docs/0J40/4.e for details
        :param device: is the id of the MaestroDevice device (0-127, default on
                       boards is 12, all device if not set)
        """
        self.__send_command_bi(0x87, servo, speed, device)

    def set_acceleration(self, servo, acceleration, device=0x80):
        """ Set the acceleration for a servo
        :param servo: is the servo number (typically 0-23)
        :param acceleration: is servo acceleration (0=full, 1=slower), 
                             in (0.25 us)/(10 ms)/(80 ms) when T=20ms. 
                             see http://www.pololu.com/docs/0J40/4.e for details
        :param device: is the id of the MaestroDevice device (0-127, default on
                       boards is 12, all device if not set)
        """
        self.__send_command_bi(0x89, servo, acceleration, device)

    def set_pwm(self, on_time, period, device=0x80):
        """ Set the pwm output of a channel (Mini MaestroDevice 12, 18 and 24
        only)
        :param on_time: is the part of the period the output will be high 
                        (unit : 1/48 us)
        :param period: is the total period length (unit : 1/48 us)
                       see http://www.pololu.com/docs/0J40/4.a for details
        """
        self.__send_command_ii(0x8A, on_time, period, device)

    def go_home(self, device=0x80):
        """ Set all servos to their home position. Servos set to "ignore" will
        remain unchanged, servos set to "off" will turn off.
        :param servo: is the servo number (typically 0-23)
        :param device: is the id of the MaestroDevice device (0-127, default on
                       boards is 12, all device if not set)
        """

        self.__send_command(0xA2, device)

    def get_position(self, servo, device=0x80):
        """ Gets the current position of a servo
        :param device: is the id of the MaestroDevice device (0-127, default on
                       boards is 12, all device if not set)
        """
        self.__send_command_b(0x90, servo, device)
        return self.__receive_int()

    def get_moving_state(self, device=0x80):
        """ Checks if some servos are moving
        :param device: is the id of the MaestroDevice device (0-127, default on
                       boards is 12, all device if not set)
        """
        self.__send_command(0x93, device)
        return self.__receive_byte()

    def get_errors(self, device=0x80):
        """ Gets the current error flags
        :param device: is the id of the MaestroDevice device (0-127, default on
                       boards is 12, all device if not set)
        """
        self.__send_command(0xA1, device)
        return self.__receive_int()

class Servo(object):

    def __init__(self, maestro, servo_number, name=None, offset_param=None):
        if name is None:
            name = 'servo' + str(servo_number)
        if offset_param is None:
            offset_param = '~servo_offset'
        cmd_name = name + '_cmd'
        status_name = name + '_status'
        self.maestro = maestro
        self.servo_number = servo_number
        self.cmd_sub = rospy.Subscriber(cmd_name, Float32,
                                        self.cmd_callback)
        self.status_pub = rospy.Publisher(status_name, Float32) 
        self.angle_offset = rospy.get_param(offset_param, 0)

    def publish(self):
        ticks = self.maestro.get_position(self.servo_number)
        angle = ticks_to_radians(ticks) - self.angle_offset
        self.status_pub.publish(angle)

    def cmd_callback(self, msg):
        angle = msg.data + self.angle_offset
        if angle < -math.pi/2 or angle > math.pi/2:
            rospy.logerr('Angle outside servo range. Moving servo to max value')
            angle = max(angle,-math.pi/2)
            angle = min(angle, math.pi/2)
        ticks = radians_to_ticks(angle)
        # Slow down servo for now
        rospy.loginfo('Setting servo to ' + str(ticks) + ' ticks.')
        self.maestro.set_speed(self.servo_number, 100)
        self.maestro.set_target(self.servo_number, ticks)

    def shutdown(self):
        self.cmd_sub.unregister()
        self.status_pub.unregister()

class PololuDriver(object):

    def __init__(self, port='/dev/polulu_servo0', baud=9600):
        rospy.init_node('pololu_driver')
        port = rospy.get_param('~port', port)
        baud = rospy.get_param('~baud', baud)
        self.maestro = MaestroDevice(port, baud)
        rospy.on_shutdown(self.shutdown)

        #TODO: Define this configuration information using ROS parameters
        self.servos = [
            Servo(self.maestro, 0, 'camera_pan', '~pan_offset'),
            Servo(self.maestro, 1, 'camera_tilt', '~tilt_offset')
        ]

        self.spin()

    def shutdown(self):
        """ Called by rospy on shutdown. """
        for servo in self.servos:
            servo.shutdown()
        self.maestro.close()

    def run(self):
        rospy.spin()

    def spin(self):
        """ Main driver loop. """
        slow_poll = rospy.Rate(0.25)    # slow poll frequency
        fast_loop = rospy.Rate(50)
        while not rospy.is_shutdown():
            if self.maestro.ok():       # device connected?
                for servo in self.servos:
                    servo.publish()
            elif self.maestro.open():   # open succeeded?
                pass
            else:
                rospy.logwarn('Device not connected!')
                slow_poll.sleep()
            fast_loop.sleep()

if __name__ == '__main__':
    node = PololuDriver()
